"""Comprehensive unit tests for all ADW output parsing functions.

This module tests:
1. copilot_output_parser.py - Core parsing functions for Copilot output
2. adw_test.py - Test result parsing from pytest
3. utils.py - JSON parsing and utility functions
4. Data type validation through Pydantic models
"""

import pytest
import re
from typing import List, Optional

# Import parsing functions
from scripts.adw_modules.copilot_output_parser import (
    strip_ansi,
    extract_keywords,
    extract_metrics,
    detect_errors_warnings,
    extract_test_results,
    extract_executed_steps,
    determine_validation_status,
    parse_copilot_output,
    ParsedCopilotOutput,
)

from scripts.adw_modules.data_types import TestResult, AgentPromptResponse

from scripts.adw_modules.utils import parse_json


# ============================================================================
# TESTS FOR strip_ansi()
# ============================================================================

class TestStripAnsi:
    """Tests for ANSI code stripping."""

    def test_strip_simple_color_codes(self):
        """Test removal of simple ANSI color codes."""
        text = "\x1B[32mHello\x1B[0m World"
        result = strip_ansi(text)
        assert result == "Hello World"

    def test_strip_bold_codes(self):
        """Test removal of bold ANSI codes."""
        text = "\x1B[1mBold Text\x1B[0m"
        result = strip_ansi(text)
        assert result == "Bold Text"

    def test_strip_256_color_codes(self):
        """Test removal of 256-color ANSI codes."""
        text = "\x1B[38;5;196mRed\x1B[0m"
        result = strip_ansi(text)
        assert result == "Red"

    def test_strip_rgb_color_codes(self):
        """Test removal of RGB ANSI codes."""
        text = "\x1B[38;2;255;0;0mRGB Red\x1B[0m"
        result = strip_ansi(text)
        assert result == "RGB Red"

    def test_strip_multiple_codes(self):
        """Test text with multiple ANSI codes."""
        text = "\x1B[1m\x1B[32mBold Green\x1B[0m \x1B[4mUnderline\x1B[0m"
        result = strip_ansi(text)
        assert result == "Bold Green Underline"

    def test_empty_string(self):
        """Test that empty strings are handled correctly."""
        assert strip_ansi("") == ""

    def test_text_without_ansi(self):
        """Test that text without ANSI codes is unchanged."""
        text = "Plain text without codes"
        assert strip_ansi(text) == text


# ============================================================================
# TESTS FOR extract_keywords()
# ============================================================================

class TestExtractKeywords:
    """Tests for keyword extraction from output."""

    def test_extract_success_keywords(self):
        """Test extraction of success indicators."""
        output = "âœ“ Implementation Summary completed successfully"
        keywords = extract_keywords(output)
        
        assert keywords['success_indicators']
        assert 'âœ“' in keywords['success_indicators']
        assert 'successfully' in keywords['success_indicators']

    def test_extract_error_keywords(self):
        """Test extraction of error indicators."""
        output = "âœ— ERROR: Something went wrong"
        keywords = extract_keywords(output)
        
        assert keywords['error_indicators']
        assert 'âœ—' in keywords['error_indicators']

    def test_extract_warning_keywords(self):
        """Test extraction of warning indicators."""
        output = "âš  WARNING: This is a warning"
        keywords = extract_keywords(output)
        
        assert keywords['warning_indicators']
        assert 'âš ' in keywords['warning_indicators']

    def test_case_insensitive_extraction(self):
        """Test that keyword extraction is case-insensitive for text."""
        output = "SUCCESS and Completed"
        keywords = extract_keywords(output)
        
        assert any(k.lower() in ['success', 'completed'] for k in keywords['success_indicators'])

    def test_empty_output(self):
        """Test behavior with empty output."""
        keywords = extract_keywords("")
        assert keywords['success_indicators'] == []
        assert keywords['error_indicators'] == []
        assert keywords['warning_indicators'] == []

    def test_all_keywords(self):
        """Test extraction when all keyword types present."""
        output = "âœ“ SUCCESS completed âœ— ERROR âš  WARNING"
        keywords = extract_keywords(output)
        
        assert keywords['success_indicators']
        assert keywords['error_indicators']
        assert keywords['warning_indicators']


# ============================================================================
# TESTS FOR extract_metrics()
# ============================================================================

class TestExtractMetrics:
    """Tests for quantitative metric extraction."""

    def test_git_commit_summary_format(self):
        """Test parsing git commit summary format."""
        output = "1 file changed, 645 insertions(+), 350 deletions(-)"
        files, added, removed = extract_metrics(output)
        
        assert files == 1
        assert added == 645
        assert removed == 350

    def test_multiple_files_changed(self):
        """Test parsing multiple files changed."""
        output = "15 files changed, 1200 insertions(+), 450 deletions(-)"
        files, added, removed = extract_metrics(output)
        
        assert files == 15
        assert added == 1200
        assert removed == 450

    def test_summary_format_with_dashes(self):
        """Test summary format with dash-prefixed metrics."""
        output = """Implementation Summary:
- Files Changed: 8
- Lines added: 645
- Lines removed: 350"""
        files, added, removed = extract_metrics(output)
        
        assert files == 8
        assert added == 645
        assert removed == 350

    def test_natural_language_format(self):
        """Test natural language metric format."""
        output = "Updated 5 files, Added 200 lines"
        files, added, removed = extract_metrics(output)
        
        assert files >= 0  # May be 0 if pattern not exact
        assert added == 200

    def test_no_metrics_found(self):
        """Test behavior when no metrics are found."""
        output = "This output has no metrics at all"
        files, added, removed = extract_metrics(output)
        
        assert files == 0
        assert added == 0
        assert removed == 0

    def test_partial_metrics(self):
        """Test extraction when only some metrics are present."""
        output = "10 files changed, 500 insertions(+)"
        files, added, removed = extract_metrics(output)
        
        assert files == 10
        assert added == 500
        assert removed == 0

    def test_case_insensitive_metrics(self):
        """Test that metric extraction is case-insensitive."""
        output = "Files CHANGED: 5, LINES ADDED: 100"
        files, added, removed = extract_metrics(output)
        
        assert files == 5
        assert added == 100

    def test_multiple_occurrences_uses_last(self):
        """Test that multiple metric occurrences use the last one."""
        output = """
        First attempt: 5 files changed, 100 insertions(+)
        Final result: 10 files changed, 200 insertions(+)
        """
        files, added, removed = extract_metrics(output)
        
        assert files == 10
        assert added == 200


# ============================================================================
# TESTS FOR detect_errors_warnings()
# ============================================================================

class TestDetectErrorsWarnings:
    """Tests for error and warning message extraction."""

    def test_extract_error_messages(self):
        """Test extraction of error messages."""
        output = "ERROR: Connection failed\nERROR: Database error"
        errors, warnings = detect_errors_warnings(output)
        
        assert len(errors) >= 1
        assert any("Connection failed" in e or "Database error" in e for e in errors)

    def test_extract_warning_messages(self):
        """Test extraction of warning messages."""
        output = "WARNING: Deprecated function used\nâš  Be careful with this"
        errors, warnings = detect_errors_warnings(output)
        
        assert len(warnings) >= 1

    def test_error_with_colon(self):
        """Test error extraction with colon format."""
        output = "Error: Something went wrong"
        errors, warnings = detect_errors_warnings(output)
        
        assert errors

    def test_failed_keyword(self):
        """Test detection of FAILED keyword."""
        output = "FAILED: Test suite did not complete"
        errors, warnings = detect_errors_warnings(output)
        
        assert errors

    def test_exception_keyword(self):
        """Test detection of Exception keyword."""
        output = "Exception: null pointer"
        errors, warnings = detect_errors_warnings(output)
        
        assert errors

    def test_filter_numeric_only_messages(self):
        """Test that numeric-only messages are filtered."""
        output = "ERROR: 0\nERROR: Connection failed"
        errors, warnings = detect_errors_warnings(output)
        
        # Should exclude the "0" message
        assert not any(e == "0" for e in errors)
        assert any("Connection failed" in e for e in errors)

    def test_empty_output(self):
        """Test behavior with no errors or warnings."""
        output = "Everything is fine"
        errors, warnings = detect_errors_warnings(output)
        
        assert errors == []
        assert warnings == []

    def test_case_insensitive_detection(self):
        """Test case-insensitive error/warning detection."""
        output = "error: test failed\nwarn: check logs"
        errors, warnings = detect_errors_warnings(output)
        
        assert errors
        assert warnings


# ============================================================================
# TESTS FOR extract_test_results()
# ============================================================================

class TestExtractTestResults:
    """Tests for test result summary extraction."""

    def test_extract_test_count(self):
        """Test extraction of test count."""
        output = "5 tests passed, 0 tests failed"
        result = extract_test_results(output)
        
        assert "5" in result or "passed" in result.lower()

    def test_extract_test_summary(self):
        """Test extraction of test summary section."""
        output = """
        Running tests...
        Test Results: 10 passed, 2 failed
        Total time: 2.5s
        """
        result = extract_test_results(output)
        
        assert result

    def test_no_test_results(self):
        """Test behavior when no test results found."""
        output = "No tests were run"
        result = extract_test_results(output)
        
        assert result == "" or "test" in result.lower()

    def test_pytest_format(self):
        """Test pytest output format."""
        output = "passed 5 failed 2 in 1.23s"
        result = extract_test_results(output)
        
        assert result  # Should find something

    def test_spec_terminology(self):
        """Test spec terminology for tests."""
        output = "2 specs passed, 0 specs failed"
        result = extract_test_results(output)
        
        assert result


# ============================================================================
# TESTS FOR extract_executed_steps()
# ============================================================================

class TestExtractExecutedSteps:
    """Tests for executed steps extraction."""

    def test_extract_numbered_steps(self):
        """Test extraction of numbered steps."""
        output = """
        Step 1: Install dependencies
        Step 2: Build project
        Step 3: Run tests
        """
        steps = extract_executed_steps(output)
        
        assert len(steps) >= 1
        # Should contain step descriptions

    def test_extract_symbol_marked_steps(self):
        """Test extraction of symbol-marked steps."""
        output = """
        âœ“ Clone repository
        âœ“ Install dependencies
        â†’ Build project
        """
        steps = extract_executed_steps(output)
        
        assert len(steps) >= 1

    def test_extract_checkmark_steps(self):
        """Test extraction of checkmark-marked steps."""
        output = """
        âœ” Step 1: Initialize
        âœ” Step 2: Configure
        """
        steps = extract_executed_steps(output)
        
        assert len(steps) >= 1

    def test_no_steps(self):
        """Test behavior when no steps are found."""
        output = "No step indicators in this output"
        steps = extract_executed_steps(output)
        
        assert steps == []

    def test_mixed_step_formats(self):
        """Test extraction of mixed step formats."""
        output = """
        Step 1: First task
        âœ“ Second task
        * Third task
        """
        steps = extract_executed_steps(output)
        
        assert len(steps) >= 1


# ============================================================================
# TESTS FOR determine_validation_status()
# ============================================================================

class TestDetermineValidationStatus:
    """Tests for validation status determination."""

    def test_explicit_success_phrase(self):
        """Test detection of explicit success phrase."""
        keywords = {
            'success_indicators': ['Implementation Complete'],
            'error_indicators': [],
            'warning_indicators': []
        }
        output = "Implementation Complete! âœ…"
        status = determine_validation_status(keywords, [], [], output)
        
        assert status == "passed"

    def test_success_with_no_warnings(self):
        """Test success status when indicators present but no warnings."""
        keywords = {
            'success_indicators': ['successfully'],
            'error_indicators': [],
            'warning_indicators': []
        }
        status = determine_validation_status(keywords, [], [], "")
        
        assert status == "passed"

    def test_success_with_warnings(self):
        """Test partial status when success but warnings present."""
        keywords = {
            'success_indicators': ['successfully'],
            'error_indicators': [],
            'warning_indicators': ['deprecated']
        }
        status = determine_validation_status(keywords, [], ["Some warning"], "")
        
        assert status == "partial"

    def test_error_status(self):
        """Test failure status when errors present."""
        keywords = {
            'success_indicators': [],
            'error_indicators': [],
            'warning_indicators': []
        }
        errors = ["Connection failed"]
        status = determine_validation_status(keywords, errors, [], "")
        
        assert status == "failed"

    def test_error_indicator_without_success(self):
        """Test failure when error indicator without success indicator."""
        keywords = {
            'success_indicators': [],
            'error_indicators': ['âœ—'],
            'warning_indicators': []
        }
        status = determine_validation_status(keywords, [], [], "")
        
        assert status == "failed"

    def test_files_changed_positive_indicator(self):
        """Test passed status when files changed."""
        keywords = {
            'success_indicators': [],
            'error_indicators': [],
            'warning_indicators': []
        }
        status = determine_validation_status(keywords, [], [], "", files_changed=5)
        
        assert status == "passed"

    def test_files_changed_with_warnings(self):
        """Test partial status when files changed but warnings present."""
        keywords = {
            'success_indicators': [],
            'error_indicators': [],
            'warning_indicators': []
        }
        status = determine_validation_status(keywords, [], ["warning"], "", files_changed=5)
        
        assert status == "partial"

    def test_unknown_status(self):
        """Test unknown status when no indicators present."""
        keywords = {
            'success_indicators': [],
            'error_indicators': [],
            'warning_indicators': []
        }
        status = determine_validation_status(keywords, [], [], "", files_changed=0)
        
        assert status == "unknown"

    def test_explicit_success_overrides_all(self):
        """Test that explicit success phrase overrides all other indicators."""
        keywords = {
            'success_indicators': [],
            'error_indicators': ['âœ—'],
            'warning_indicators': []
        }
        output = "Implementation Complete! âœ…"
        status = determine_validation_status(keywords, ["Error"], ["Warning"], output)
        
        assert status == "passed"


# ============================================================================
# TESTS FOR parse_copilot_output()
# ============================================================================

class TestParseCopilotOutput:
    """Tests for complete copilot output parsing."""

    def test_parse_successful_implementation(self):
        """Test parsing of successful implementation output."""
        output = """Implementation Summary:
- Files Changed: 3
- Lines added: 250
- Lines removed: 100
âœ“ Implementation Complete! âœ…
All Acceptance Criteria Met"""
        
        result = parse_copilot_output(output)
        
        assert result.success is True
        assert result.files_changed == 3
        assert result.lines_added == 250
        assert result.lines_removed == 100
        assert result.validation_status == "passed"

    def test_parse_failed_implementation(self):
        """Test parsing of failed implementation output."""
        output = """ERROR: Connection to database failed
Exception: Unable to connect to host
Implementation failed"""
        
        result = parse_copilot_output(output)
        
        assert result.success is False
        assert len(result.errors) > 0
        assert result.validation_status == "failed"

    def test_parse_partial_success(self):
        """Test parsing of partial success with warnings."""
        output = """âœ“ Implementation Complete
5 files changed, 300 insertions(+)
WARNING: Deprecated API used"""
        
        result = parse_copilot_output(output)
        
        assert result.files_changed == 5
        assert result.lines_added == 300
        assert len(result.warnings) > 0

    def test_parse_with_ansi_codes(self):
        """Test parsing output with ANSI color codes."""
        output = "\x1B[32mâœ“ Implementation Complete\x1B[0m\n5 files changed"
        
        result = parse_copilot_output(output)
        
        assert result.success is True
        assert result.files_changed == 5

    def test_parse_empty_output(self):
        """Test parsing of empty output."""
        result = parse_copilot_output("")
        
        assert result.success is False
        assert result.validation_status == "empty"

    def test_parse_preserves_raw_output(self):
        """Test that raw output is preserved."""
        output = "Test output data"
        result = parse_copilot_output(output)
        
        assert result.raw_output == output

    def test_parse_test_results_extraction(self):
        """Test that test results are extracted."""
        output = """
        Running tests...
        10 tests passed, 0 failed
        Implementation Complete"""
        
        result = parse_copilot_output(output)
        
        assert len(result.test_results) > 0 or result.success


# ============================================================================
# TESTS FOR parse_json()
# ============================================================================

class TestParseJson:
    """Tests for JSON parsing with markdown handling."""

    def test_parse_raw_json_object(self):
        """Test parsing raw JSON object."""
        json_str = '{"key": "value", "number": 42}'
        result = parse_json(json_str)
        
        assert result == {"key": "value", "number": 42}

    def test_parse_raw_json_array(self):
        """Test parsing raw JSON array."""
        json_str = '[{"id": 1}, {"id": 2}]'
        result = parse_json(json_str)
        
        assert isinstance(result, list)
        assert len(result) == 2

    def test_parse_markdown_code_block_json(self):
        """Test parsing JSON in markdown code block."""
        text = '''```json
{"key": "value"}
```'''
        result = parse_json(text)
        
        assert result == {"key": "value"}

    def test_parse_markdown_code_block_without_language(self):
        """Test parsing JSON in markdown code block without language tag."""
        text = '''```
{"key": "value"}
```'''
        result = parse_json(text)
        
        assert result == {"key": "value"}

    def test_parse_json_with_extra_text(self):
        """Test parsing JSON with surrounding text."""
        text = 'Here is the JSON: {"key": "value"} end'
        result = parse_json(text)
        
        assert result == {"key": "value"}

    def test_parse_json_with_whitespace(self):
        """Test parsing JSON with extra whitespace."""
        json_str = '  \n  {"key": "value"}  \n  '
        result = parse_json(json_str)
        
        assert result == {"key": "value"}

    def test_parse_json_array_extraction(self):
        """Test JSON array extraction from text."""
        text = 'Results: [{"id": 1}, {"id": 2}]'
        result = parse_json(text)
        
        assert isinstance(result, list)
        assert len(result) == 2

    def test_parse_json_with_pydantic_model(self):
        """Test parsing JSON into Pydantic model."""
        json_str = '{"test_name": "test_1", "passed": true}'
        result = parse_json(json_str, target_type=TestResult)
        
        assert isinstance(result, TestResult)
        assert result.test_name == "test_1"
        assert result.passed is True

    def test_parse_json_list_with_pydantic_models(self):
        """Test parsing JSON array into list of Pydantic models."""
        json_str = '''[
            {"test_name": "test_1", "passed": true},
            {"test_name": "test_2", "passed": false}
        ]'''
        result = parse_json(json_str, target_type=List[TestResult])
        
        assert isinstance(result, list)
        assert len(result) == 2
        assert all(isinstance(item, TestResult) for item in result)

    def test_parse_invalid_json_raises_error(self):
        """Test that invalid JSON raises ValueError."""
        with pytest.raises(ValueError):
            parse_json("{ invalid json }")

    def test_parse_json_nested_structure(self):
        """Test parsing nested JSON structures."""
        json_str = '''{
            "data": {
                "items": [1, 2, 3],
                "status": "success"
            }
        }'''
        result = parse_json(json_str)
        
        assert result["data"]["status"] == "success"
        assert result["data"]["items"] == [1, 2, 3]


# ============================================================================
# INTEGRATION TESTS
# ============================================================================

class TestParsingIntegration:
    """Integration tests combining multiple parsing functions."""

    def test_full_pipeline_successful_run(self):
        """Test complete parsing pipeline for successful run."""
        full_output = """
        \x1B[32mâœ“ Implementation Complete\x1B[0m
        
        Summary:
        - 5 files changed
        - 450 insertions(+)
        - 200 deletions(-)
        
        Tests: 15 passed, 0 failed
        
        All Acceptance Criteria Met âœ…
        """
        
        result = parse_copilot_output(full_output)
        
        # Verify all components parsed correctly
        assert result.success is True
        assert result.files_changed == 5
        assert result.lines_added == 450
        assert result.lines_removed == 200
        assert result.validation_status == "passed"
        assert len(result.test_results) > 0

    def test_full_pipeline_failed_run(self):
        """Test complete parsing pipeline for failed run."""
        full_output = """
        Starting implementation...
        ERROR: Database connection failed
        Exception: Cannot reach database host
        
        âœ— Implementation Failed
        0 files changed
        """
        
        result = parse_copilot_output(full_output)
        
        # Verify failure detected
        assert result.success is False
        assert len(result.errors) > 0
        assert result.validation_status == "failed"

    def test_full_pipeline_partial_success(self):
        """Test complete parsing pipeline for partial success."""
        full_output = """
        âœ“ Implementation Completed
        8 files changed, 600 insertions(+), 150 deletions(-)
        
        Tests: 20 passed, 2 failed
        WARNING: Some tests need review
        âš  Performance may be affected
        """
        
        result = parse_copilot_output(full_output)
        
        # Verify partial success captured
        assert result.files_changed == 8
        assert result.lines_added == 600
        assert len(result.warnings) > 0

    def test_pipeline_preserves_all_data(self):
        """Test that complete pipeline preserves all important data."""
        output = """
        Step 1: Initialize project
        âœ“ Step 2: Install dependencies
        â†’ Step 3: Build application
        
        5 files changed, 400 insertions(+)
        WARNING: Use latest version of library
        Implementation Summary complete
        """
        
        result = parse_copilot_output(output)
        
        # Verify key data is preserved
        assert result.files_changed > 0
        assert result.lines_added > 0
        assert len(result.warnings) > 0
        assert len(result.executed_steps) > 0


# ============================================================================
# EDGE CASES AND ERROR HANDLING
# ============================================================================

class TestEdgeCasesAndErrors:
    """Tests for edge cases and error handling."""

    def test_parse_very_large_output(self):
        """Test parsing of very large output."""
        large_output = "Test line\n" * 10000
        result = parse_copilot_output(large_output)
        
        # Should handle large output without crashing
        assert result is not None

    def test_parse_unicode_characters(self):
        """Test parsing output with unicode characters."""
        output = "âœ“ Success å®Œæˆ å®Œäº† âœ… ğŸ‰"
        result = parse_copilot_output(output)
        
        # Should parse without error
        assert result is not None

    def test_parse_special_regex_characters(self):
        """Test parsing output with special regex characters."""
        output = "ERROR: Failed to match pattern [a-z]+ and \\n (special)"
        result = parse_copilot_output(output)
        
        # Should handle special characters without crashing
        assert result is not None

    def test_parse_deeply_nested_json(self):
        """Test parsing deeply nested JSON."""
        json_str = '{"a": {"b": {"c": {"d": {"e": "value"}}}}}'
        result = parse_json(json_str)
        
        assert result["a"]["b"]["c"]["d"]["e"] == "value"

    def test_parse_json_with_escaped_quotes(self):
        """Test parsing JSON with escaped quotes."""
        json_str = '{"message": "He said \\"hello\\""}'
        result = parse_json(json_str)
        
        assert result["message"] == 'He said "hello"'

    def test_metrics_with_plurals(self):
        """Test metric extraction handles plural forms."""
        output_singular = "1 file changed, 10 insertion(+)"
        output_plural = "5 files changed, 50 insertions(+)"
        
        s_files, s_added, _ = extract_metrics(output_singular)
        p_files, p_added, _ = extract_metrics(output_plural)
        
        assert s_files == 1
        assert p_files == 5
        assert s_added == 10
        assert p_added == 50


if __name__ == '__main__':
    pytest.main([__file__, '-v'])
